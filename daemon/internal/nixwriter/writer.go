// Package nixwriter bridges D-PlaneOS's imperative management layer with
// NixOS's declarative configuration system.
//
// The fundamental problem this solves:
//   - D-PlaneOS UI makes imperative changes (netlink calls, SMB config writes)
//   - NixOS owns the system declaratively — on every nixos-rebuild, it resets
//     any state it doesn't know about back to what's in configuration.nix
//   - Result: UI changes survive until next rebuild, then silently disappear
//
// The solution:
//   - Every persistent UI change writes a Nix fragment to
//     /etc/nixos/dplane-generated.nix
//   - configuration.nix imports that file (setup-nixos.sh adds the import)
//   - Changes are applied BOTH imperatively (instant effect) AND declaratively
//     (survives rebuilds forever)
//
// Fragment format: pure Nix attribute set merged via lib.mkMerge in the import.
package nixwriter

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"
)

const (
	// DefaultFragmentPath is where generated Nix config lives.
	// Must be imported by configuration.nix.
	DefaultFragmentPath = "/etc/nixos/dplane-generated.nix"

	// Header written at the top of every generated fragment.
	fileHeader = `# dplane-generated.nix
# ──────────────────────────────────────────────────────────────────────────────
# AUTO-GENERATED by D-PlaneOS. DO NOT EDIT BY HAND.
# Changes made via the D-PlaneOS web UI are written here automatically.
# This file is imported by configuration.nix:
#   imports = [ ./dplane-generated.nix ];
#
# Last updated: %s
# ──────────────────────────────────────────────────────────────────────────────

{ config, lib, pkgs, ... }:

{
`
	fileFooter = `}
`
)

// Writer manages the dplane-generated.nix fragment.
// It holds the current desired state as a map of Nix stanzas,
// serialises them to a syntactically valid .nix file, and optionally
// triggers nixos-rebuild switch.
type Writer struct {
	mu           sync.Mutex
	path         string
	stanzas      map[string]string // key → nix expression (one per concern)
	nixOS        bool              // false on non-NixOS: writes are silently skipped
	rebuildAfter bool              // trigger nixos-rebuild switch after every write
}

// New returns a Writer targeting fragmentPath.
// If the system is not NixOS, all writes are no-ops (safe to use everywhere).
func New(fragmentPath string, triggerRebuild bool) *Writer {
	return &Writer{
		path:         fragmentPath,
		stanzas:      make(map[string]string),
		nixOS:        isNixOS(),
		rebuildAfter: triggerRebuild,
	}
}

// DefaultWriter returns a Writer using the standard path and no auto-rebuild.
// Callers trigger nixos-rebuild explicitly via the NixOS guard handler.
func DefaultWriter() *Writer {
	return New(DefaultFragmentPath, false)
}

func isNixOS() bool {
	_, err := os.Stat("/etc/NIXOS")
	return err == nil
}

// IsNixOS reports whether this system is NixOS.
func (w *Writer) IsNixOS() bool { return w.nixOS }

// ── Network stanzas ───────────────────────────────────────────────────────────

// SetStaticInterface writes a static IP assignment for an interface.
// Overwrites any previous static config for that interface.
//
// Example output in generated Nix:
//
//	systemd.network.networks."20-eth0-static" = { ... };
func (w *Writer) SetStaticInterface(iface, cidr, gateway string) error {
	if !validateIface(iface) {
		return fmt.Errorf("invalid interface name: %q", iface)
	}
	if cidr != "" && !validateCIDR(cidr) {
		return fmt.Errorf("invalid CIDR: %q", cidr)
	}
	key := "net-static-" + iface

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf(`  # Static IP for %s — set via D-PlaneOS web UI`+"\n", iface))
	sb.WriteString(fmt.Sprintf(`  systemd.network.networks."20-%s-static" = {`+"\n", iface))
	sb.WriteString(fmt.Sprintf(`    matchConfig.Name = %q;`+"\n", iface))
	if cidr != "" {
		sb.WriteString(`    networkConfig.DHCP = "no";` + "\n")
		sb.WriteString(fmt.Sprintf(`    address = [ %q ];`+"\n", cidr))
		if gateway != "" {
			sb.WriteString(fmt.Sprintf(`    routes = [{ routeConfig = { Gateway = %q; }; }];`+"\n", gateway))
		}
	} else {
		sb.WriteString(`    networkConfig.DHCP = "yes";` + "\n")
	}
	sb.WriteString(`  };` + "\n")

	return w.setStanza(key, sb.String())
}

// RemoveStaticInterface removes the static IP stanza for an interface,
// reverting to DHCP on next rebuild.
func (w *Writer) RemoveStaticInterface(iface string) error {
	w.mu.Lock()
	delete(w.stanzas, "net-static-"+iface)
	w.mu.Unlock()
	return w.flush()
}

// SetBond writes a persistent bond interface declaration.
// On NixOS, bonding is declared via systemd.network — this generates
// the appropriate .netdev and .network stanzas.
func (w *Writer) SetBond(name string, slaves []string, mode string) error {
	if !validateIface(name) {
		return fmt.Errorf("invalid bond name: %q", name)
	}
	for _, s := range slaves {
		if !validateIface(s) {
			return fmt.Errorf("invalid slave interface: %q", s)
		}
	}
	// Map mode strings to systemd-networkd equivalents
	modeMap := map[string]string{
		"balance-rr":    "balance-rr",
		"active-backup": "active-backup",
		"balance-xor":   "balance-xor",
		"broadcast":     "broadcast",
		"802.3ad":       "802.3ad",
		"balance-tlb":   "balance-tlb",
		"balance-alb":   "balance-alb",
	}
	ndMode, ok := modeMap[mode]
	if !ok {
		return fmt.Errorf("unknown bond mode: %q", mode)
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("  # Bond %s (%s) — set via D-PlaneOS web UI\n", name, mode))

	// .netdev stanza — creates the bond device
	sb.WriteString(fmt.Sprintf("  systemd.network.netdevs.\"10-%s\" = {\n", name))
	sb.WriteString(fmt.Sprintf("    netdevConfig = { Name = %q; Kind = \"bond\"; };\n", name))
	sb.WriteString(fmt.Sprintf("    bondConfig.Mode = %q;\n", ndMode))
	sb.WriteString("  };\n")

	// .network stanza — bind slaves
	for i, slave := range slaves {
		sb.WriteString(fmt.Sprintf("  systemd.network.networks.\"%02d-%s-slave\" = {\n", 20+i, slave))
		sb.WriteString(fmt.Sprintf("    matchConfig.Name = %q;\n", slave))
		sb.WriteString(fmt.Sprintf("    networkConfig.Bond = %q;\n", name))
		sb.WriteString("  };\n")
	}

	return w.setStanza("net-bond-"+name, sb.String())
}

// RemoveBond removes the bond declaration.
func (w *Writer) RemoveBond(name string) error {
	w.mu.Lock()
	delete(w.stanzas, "net-bond-"+name)
	w.mu.Unlock()
	return w.flush()
}

// SetVLAN writes a persistent VLAN interface declaration.
func (w *Writer) SetVLAN(ifName string, parent string, vid int) error {
	if !validateIface(ifName) || !validateIface(parent) {
		return fmt.Errorf("invalid interface name")
	}
	if vid < 1 || vid > 4094 {
		return fmt.Errorf("VLAN ID %d out of range 1-4094", vid)
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("  # VLAN %s (id %d on %s) — set via D-PlaneOS web UI\n", ifName, vid, parent))
	sb.WriteString(fmt.Sprintf("  systemd.network.netdevs.\"10-%s\" = {\n", ifName))
	sb.WriteString(fmt.Sprintf("    netdevConfig = { Name = %q; Kind = \"vlan\"; };\n", ifName))
	sb.WriteString(fmt.Sprintf("    vlanConfig.Id = %d;\n", vid))
	sb.WriteString("  };\n")
	// Attach VLAN to parent
	sb.WriteString(fmt.Sprintf("  systemd.network.networks.\"10-%s-vlan\" = {\n", parent))
	sb.WriteString(fmt.Sprintf("    matchConfig.Name = %q;\n", parent))
	sb.WriteString(fmt.Sprintf("    networkConfig.VLAN = [ %q ];\n", ifName))
	sb.WriteString("  };\n")

	return w.setStanza("net-vlan-"+ifName, sb.String())
}

// RemoveVLAN removes the VLAN declaration.
func (w *Writer) RemoveVLAN(ifName string) error {
	w.mu.Lock()
	delete(w.stanzas, "net-vlan-"+ifName)
	w.mu.Unlock()
	return w.flush()
}

// ── DNS stanzas ───────────────────────────────────────────────────────────────

// SetDNS writes persistent DNS server configuration.
func (w *Writer) SetDNS(servers []string) error {
	for _, s := range servers {
		if !validateIP(s) {
			return fmt.Errorf("invalid DNS server IP: %q", s)
		}
	}
	if len(servers) == 0 {
		w.mu.Lock()
		delete(w.stanzas, "dns")
		w.mu.Unlock()
		return w.flush()
	}

	quoted := make([]string, len(servers))
	for i, s := range servers {
		quoted[i] = fmt.Sprintf("%q", s)
	}

	stanza := fmt.Sprintf(
		"  # DNS servers — set via D-PlaneOS web UI\n"+
			"  networking.nameservers = [ %s ];\n",
		strings.Join(quoted, " "),
	)
	return w.setStanza("dns", stanza)
}

// ── Hostname stanza ───────────────────────────────────────────────────────────

// SetHostname writes the system hostname declaratively.
func (w *Writer) SetHostname(name string) error {
	if !validateHostname(name) {
		return fmt.Errorf("invalid hostname: %q", name)
	}
	stanza := fmt.Sprintf(
		"  # Hostname — set via D-PlaneOS web UI\n"+
			"  networking.hostName = %q;\n",
		name,
	)
	return w.setStanza("hostname", stanza)
}

// ── NTP stanza ────────────────────────────────────────────────────────────────

// SetNTP writes NTP server configuration.
func (w *Writer) SetNTP(servers []string) error {
	if len(servers) == 0 {
		w.mu.Lock()
		delete(w.stanzas, "ntp")
		w.mu.Unlock()
		return w.flush()
	}
	quoted := make([]string, len(servers))
	for i, s := range servers {
		quoted[i] = fmt.Sprintf("%q", s)
	}
	stanza := fmt.Sprintf(
		"  # NTP servers — set via D-PlaneOS web UI\n"+
			"  networking.timeServers = [ %s ];\n",
		strings.Join(quoted, " "),
	)
	return w.setStanza("ntp", stanza)
}

// ── Firewall stanza ───────────────────────────────────────────────────────────

// SetFirewallPorts writes allowed TCP/UDP ports declaratively.
// This REPLACES the entire ports list — callers must pass the complete desired set.
func (w *Writer) SetFirewallPorts(tcpPorts, udpPorts []int) error {
	tcpStr := intsToNix(tcpPorts)
	udpStr := intsToNix(udpPorts)
	stanza := fmt.Sprintf(
		"  # Firewall — managed via D-PlaneOS web UI\n"+
			"  networking.firewall.enable = true;\n"+
			"  networking.firewall.allowedTCPPorts = %s;\n"+
			"  networking.firewall.allowedUDPPorts = %s;\n",
		tcpStr, udpStr,
	)
	return w.setStanza("firewall", stanza)
}

// ── Timezone stanza ───────────────────────────────────────────────────────────

// SetTimezone writes the system timezone.
func (w *Writer) SetTimezone(tz string) error {
	// Basic validation — no shell metacharacters
	if strings.ContainsAny(tz, ";|&$`\\'\"") || len(tz) > 64 {
		return fmt.Errorf("invalid timezone: %q", tz)
	}
	stanza := fmt.Sprintf(
		"  # Timezone — set via D-PlaneOS web UI\n"+
			"  time.timeZone = %q;\n",
		tz,
	)
	return w.setStanza("timezone", stanza)
}

// ── Core mechanics ────────────────────────────────────────────────────────────

// setStanza updates one stanza and flushes the file.
func (w *Writer) setStanza(key, content string) error {
	w.mu.Lock()
	w.stanzas[key] = content
	w.mu.Unlock()
	return w.flush()
}

// flush serialises all stanzas to the fragment file atomically.
// On non-NixOS systems this is a deliberate no-op.
func (w *Writer) flush() error {
	if !w.nixOS {
		return nil // not NixOS — imperative changes only
	}

	w.mu.Lock()
	defer w.mu.Unlock()

	// Build file content
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf(fileHeader, time.Now().UTC().Format("2006-01-02 15:04:05 UTC")))
	for _, stanza := range w.stanzas {
		sb.WriteString(stanza)
		sb.WriteString("\n")
	}
	sb.WriteString(fileFooter)

	content := []byte(sb.String())

	// Atomic write: write to .tmp then rename
	dir := filepath.Dir(w.path)
	tmp, err := os.CreateTemp(dir, ".dplane-generated-*.nix.tmp")
	if err != nil {
		return fmt.Errorf("nixwriter: create tmp: %w", err)
	}
	tmpPath := tmp.Name()

	if _, err := tmp.Write(content); err != nil {
		tmp.Close()
		os.Remove(tmpPath)
		return fmt.Errorf("nixwriter: write tmp: %w", err)
	}
	if err := tmp.Close(); err != nil {
		os.Remove(tmpPath)
		return fmt.Errorf("nixwriter: close tmp: %w", err)
	}
	if err := os.Rename(tmpPath, w.path); err != nil {
		os.Remove(tmpPath)
		return fmt.Errorf("nixwriter: rename: %w", err)
	}

	return nil
}

// LoadFromDisk reads an existing fragment and parses stanzas back into memory.
// Called at daemon startup so in-memory state matches the file on disk.
// If the file doesn't exist yet, this is a no-op.
func (w *Writer) LoadFromDisk() error {
	if !w.nixOS {
		return nil
	}
	// We don't parse Nix syntax — we just confirm the file is present
	// and non-empty so subsequent writes extend rather than clobber it.
	// Full round-trip parsing would require a Nix parser; out of scope.
	// The in-memory stanzas map starts empty; callers call Set* methods
	// on startup based on DB state (see reconciler).
	_, err := os.Stat(w.path)
	if os.IsNotExist(err) {
		return nil // file will be created on first write
	}
	return err
}

// ── Validation helpers (no shell metacharacters, no injection) ────────────────

func validateIface(s string) bool {
	if len(s) == 0 || len(s) > 16 {
		return false
	}
	for _, c := range s {
		if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
			(c >= '0' && c <= '9') || c == '-' || c == '_' || c == '.') {
			return false
		}
	}
	return true
}

func validateIP(s string) bool {
	if len(s) == 0 || len(s) > 45 {
		return false
	}
	for _, c := range s {
		if !((c >= '0' && c <= '9') || c == '.' || c == ':') {
			return false
		}
	}
	return true
}

func validateCIDR(s string) bool {
	if !strings.Contains(s, "/") {
		return false
	}
	parts := strings.SplitN(s, "/", 2)
	return validateIP(parts[0]) && len(parts[1]) > 0 && len(parts[1]) <= 3
}

func validateHostname(s string) bool {
	if len(s) == 0 || len(s) > 63 {
		return false
	}
	for _, c := range s {
		if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
			(c >= '0' && c <= '9') || c == '-') {
			return false
		}
	}
	return true
}

func intsToNix(ports []int) string {
	if len(ports) == 0 {
		return "[ ]"
	}
	parts := make([]string, len(ports))
	for i, p := range ports {
		parts[i] = fmt.Sprintf("%d", p)
	}
	return "[ " + strings.Join(parts, " ") + " ]"
}

// ── Samba global settings stanzas ─────────────────────────────────────────────
// These update services.dplaneos.samba options in dplane-generated.nix
// so nixos-rebuild picks up global SMB settings changes from the UI.

// SetSambaGlobals writes the global Samba settings (workgroup, server string,
// VFS toggles) as NixOS module options into the generated fragment.
// On the next nixos-rebuild, NixOS applies these to the [global] smb.conf section.
func (w *Writer) SetSambaGlobals(opts SambaGlobalOpts) error {
	var sb strings.Builder
	sb.WriteString("  # Samba global settings — set via D-PlaneOS web UI\n")
	sb.WriteString("  services.dplaneos.samba.enable = true;\n")

	if opts.Workgroup != "" {
		sb.WriteString(fmt.Sprintf("  services.dplaneos.samba.workgroup = %q;\n", opts.Workgroup))
	}
	if opts.ServerString != "" {
		sb.WriteString(fmt.Sprintf("  services.dplaneos.samba.serverString = %q;\n", opts.ServerString))
	}
	if opts.TimeMachine {
		sb.WriteString("  services.dplaneos.samba.timeMachine = true;\n")
	} else {
		sb.WriteString("  services.dplaneos.samba.timeMachine = false;\n")
	}
	if opts.AllowGuest {
		sb.WriteString("  services.dplaneos.samba.allowGuest = true;\n")
	} else {
		sb.WriteString("  services.dplaneos.samba.allowGuest = false;\n")
	}
	if opts.ExtraGlobal != "" {
		// Multi-line string in Nix uses ''...''
		// Escape any '' in the content itself
		escaped := strings.ReplaceAll(opts.ExtraGlobal, "''", "'''")
		sb.WriteString(fmt.Sprintf("  services.dplaneos.samba.extraGlobalConfig = ''\n%s\n'';\n", escaped))
	}

	return w.setStanza("samba-globals", sb.String())
}

// SambaGlobalOpts holds the global Samba settings as a typed struct,
// parsed from the `settings` table in the D-PlaneOS database.
type SambaGlobalOpts struct {
	Workgroup    string
	ServerString string
	TimeMachine  bool
	AllowGuest   bool
	ExtraGlobal  string
}
