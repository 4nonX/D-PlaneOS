name: D-PlaneOS CI

on:
  push:
    branches: ["main", "master"]
  pull_request:
    branches: ["main", "master"]

jobs:
  # ── Job 1: Build ────────────────────────────────────────────────────────────
  build:
    name: Build daemon binary
    runs-on: ubuntu-22.04

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: daemon/go.mod
          cache-dependency-path: daemon/go.sum

      - name: Install CGO dependencies
        run: sudo apt-get install -y gcc libc6-dev

      - name: Build
        working-directory: daemon
        run: |
          CGO_ENABLED=1 go build \
            -tags sqlite_fts5 \
            -ldflags="-s -w -X main.Version=$(cat ../VERSION)" \
            -o ../dplaned-ci \
            ./cmd/dplaned/

      - name: Verify binary reports correct version
        run: |
          EXPECTED="$(cat VERSION)"
          GOT=$(strings dplaned-ci | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
          echo "Expected: $EXPECTED  Got: $GOT"
          [ "$GOT" = "$EXPECTED" ]

      - name: Upload binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: dplaned-binary
          path: dplaned-ci
          retention-days: 1

  # ── Job 2: Integration test ─────────────────────────────────────────────────
  integration:
    name: Integration test (ZFS + daemon + API)
    runs-on: ubuntu-22.04
    needs: build

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download binary
        uses: actions/download-artifact@v4
        with:
          name: dplaned-binary

      - name: Install ZFS and runtime deps
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y zfsutils-linux sqlite3 python3-bcrypt curl
          # Load ZFS kernel module
          sudo modprobe zfs
          zpool version

      - name: Create virtual disks and ZFS pool
        run: |
          # Three 512MB sparse files — enough to test raidz1 without eating disk quota
          sudo truncate -s 512M /tmp/vdisk0.img
          sudo truncate -s 512M /tmp/vdisk1.img
          sudo truncate -s 512M /tmp/vdisk2.img
          LOOP0=$(sudo losetup --find --show /tmp/vdisk0.img)
          LOOP1=$(sudo losetup --find --show /tmp/vdisk1.img)
          LOOP2=$(sudo losetup --find --show /tmp/vdisk2.img)
          echo "LOOP0=$LOOP0" >> $GITHUB_ENV
          echo "LOOP1=$LOOP1" >> $GITHUB_ENV
          echo "LOOP2=$LOOP2" >> $GITHUB_ENV
          # Create a raidz1 pool — exactly what a user would do
          sudo zpool create -f testpool raidz1 "$LOOP0" "$LOOP1" "$LOOP2"
          sudo zpool status testpool
          echo "ZFS pool created successfully"

      - name: Initialise database
        run: |
          sudo mkdir -p /var/lib/dplaneos
          # Run the schema init script (uses sqlite3, which we installed above)
          sudo bash scripts/init-database-with-lock.sh
          sudo sqlite3 /var/lib/dplaneos/dplaneos.db "PRAGMA journal_mode;" | grep -q "wal"
          sudo sqlite3 /var/lib/dplaneos/dplaneos.db \
            "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='files_fts';" \
            | grep -q "1"
          echo "Database: WAL mode and FTS5 confirmed"

      - name: Start daemon
        run: |
          chmod +x dplaned-ci
          sudo mkdir -p /opt/dplaneos /var/log/dplaneos /etc/dplaneos /var/lib/dplaneos
          sudo cp -r app /opt/dplaneos/app
          sudo ./dplaned-ci \
            -db /var/lib/dplaneos/dplaneos.db \
            -listen 127.0.0.1:9000 \
            -smb-conf /var/lib/dplaneos/smb-shares.conf \
            &>/tmp/dplaned.log &
          echo $! > /tmp/dplaned.pid
          # Wait up to 15 seconds for health endpoint
          for i in $(seq 1 15); do
            curl -sf http://127.0.0.1:9000/health && break
            sleep 1
          done
          curl -sf http://127.0.0.1:9000/health | grep -q "ok"
          echo "Daemon is healthy"

      - name: Seed test user in database
        run: |
          # Insert a known admin user we can log in with during tests.
          # bcrypt hash of "CiAdmin1!Test" — cost 10, generated offline.
          # We do this instead of extracting install.sh's generated password
          # because on CI there is no install.sh run.
          CI_PASS="CiAdmin1!Test"
          CI_HASH=$(python3 -c "import bcrypt; print(bcrypt.hashpw(b'$CI_PASS', bcrypt.gensalt(rounds=10)).decode())")
          sudo sqlite3 /var/lib/dplaneos/dplaneos.db \
            "INSERT OR REPLACE INTO users (username, password_hash, active, role, must_change_password)
             VALUES ('admin', '$CI_HASH', 1, 'admin', 0);"
          echo "CI_PASS=$CI_PASS" >> $GITHUB_ENV
          echo "✓ Test admin user seeded"

      - name: Full API integration tests
        run: |
          BASE="http://127.0.0.1:9000"
          PASS=0; FAIL=0
          FAILURES=""

          ok()   { echo "  ✓ $1"; PASS=$((PASS+1)); }
          fail() { echo "  ✗ $1"; FAIL=$((FAIL+1)); FAILURES="${FAILURES}\n  ✗ $1"; }

          # Helper: assert JSON key equals expected value (or is truthy if no expected)
          assert_json() {
            local label="$1" resp="$2" key="$3" expected="${4:-}"
            if echo "$resp" | python3 -c "
          import sys,json
          try: d=json.load(sys.stdin)
          except: sys.exit(1)
          val=d
          for k in '$key'.split('.'): val=val.get(k) if isinstance(val,dict) else None
          sys.exit(0 if (str(val).lower()=='$expected'.lower() if '$expected' else bool(val)) else 1)
          " 2>/dev/null; then
              ok "$label"
            else
              fail "$label (got: $(echo "$resp" | head -c 150))"
            fi
          }

          # ── Phase 1: Unauthenticated surface ─────────────────────────────────

          HEALTH=$(curl -sf --max-time 5 "$BASE/health")
          assert_json "/health → ok" "$HEALTH" "status" "ok"

          CSRF_RESP=$(curl -sf --max-time 5 "$BASE/api/csrf")
          assert_json "/api/csrf → csrf_token" "$CSRF_RESP" "csrf_token"
          SESSION_TOKEN=$(echo "$CSRF_RESP" | python3 -c \
            "import sys,json; print(json.load(sys.stdin).get('csrf_token',''))" 2>/dev/null || echo "")

          # Unauthenticated access to protected endpoint must return 401
          CODE=$(curl -sf --max-time 5 -o /dev/null -w "%{http_code}" "$BASE/api/zfs/pools")
          [ "$CODE" = "401" ] && ok "Unauth ZFS pools → 401" || fail "Unauth ZFS pools → $CODE (want 401)"

          # ── Phase 2: Auth ─────────────────────────────────────────────────────

          LOGIN=$(curl -sf --max-time 10 -X POST "$BASE/api/auth/login" \
            -H "Content-Type: application/json" \
            -d "{\"username\":\"admin\",\"password\":\"$CI_PASS\"}")
          assert_json "Login → success" "$LOGIN" "success" "true"
          assert_json "Login → session_id present" "$LOGIN" "session_id"
          SESSION=$(echo "$LOGIN" | python3 -c \
            "import sys,json; print(json.load(sys.stdin).get('session_id',''))" 2>/dev/null || echo "")

          # Wrong password → 401
          BAD=$(curl -sf --max-time 5 -o /dev/null -w "%{http_code}" \
            -X POST "$BASE/api/auth/login" \
            -H "Content-Type: application/json" \
            -d '{"username":"admin","password":"wrongpass"}')
          [ "$BAD" = "401" ] && ok "Wrong password → 401" || fail "Wrong password → $BAD (want 401)"

          # Invalid username format → 400
          BAD2=$(curl -sf --max-time 5 -o /dev/null -w "%{http_code}" \
            -X POST "$BASE/api/auth/login" \
            -H "Content-Type: application/json" \
            -d '{"username":"ad min<>","password":"x"}')
          [ "$BAD2" = "400" ] && ok "Invalid username → 400" || fail "Invalid username → $BAD2 (want 400)"

          # Auth check with valid session
          CHECK=$(curl -sf --max-time 5 "$BASE/api/auth/check" -H "X-Session-ID: $SESSION")
          assert_json "Auth check → authenticated" "$CHECK" "authenticated" "true"

          # Session info
          SES=$(curl -sf --max-time 5 "$BASE/api/auth/session" -H "X-Session-ID: $SESSION" -H "X-User: admin")
          assert_json "Session → role=admin" "$SES" "user.role" "admin"

          # Password complexity rejected
          WEAK=$(curl -sf --max-time 5 -X POST "$BASE/api/auth/change-password" \
            -H "X-Session-ID: $SESSION" -H "X-User: admin" \
            -H "Content-Type: application/json" \
            -d "{\"current_password\":\"$CI_PASS\",\"new_password\":\"weak\"}")
          assert_json "Weak password rejected" "$WEAK" "success" "false"

          # Garbage session rejected
          GARB=$(curl -sf --max-time 5 -o /dev/null -w "%{http_code}" \
            "$BASE/api/zfs/pools" -H "X-Session-ID: notvalid")
          [ "$GARB" = "401" ] && ok "Garbage session → 401" || fail "Garbage session → $GARB (want 401)"

          # ── Helper for authenticated calls ────────────────────────────────────
          api() {
            local method="$1" path="$2" body="${3:-}"
            local args=(-sf --max-time 15 -X "$method" "$BASE$path"
                        -H "X-Session-ID: $SESSION" -H "X-User: admin"
                        -H "Content-Type: application/json")
            [ -n "$body" ] && args+=(-d "$body")
            curl "${args[@]}" 2>/dev/null || echo '{"_err":true}'
          }
          valid_json() { echo "$1" | python3 -c "import sys,json; json.load(sys.stdin)" 2>/dev/null; }

          # ── Phase 3: System endpoints ─────────────────────────────────────────

          assert_json "System status" "$(api GET /api/system/status)" "success" "true"
          assert_json "System profile" "$(api GET /api/system/profile)" "success" "true"
          assert_json "System preflight" "$(api GET /api/system/preflight)" "success" "true"
          valid_json "$(api GET /api/system/network)"   && ok "System network → valid JSON"   || fail "System network → invalid JSON"
          valid_json "$(api GET '/api/system/logs?lines=20')" && ok "System logs → valid JSON" || fail "System logs → invalid JSON"
          assert_json "Metrics current" "$(api GET /api/metrics/current)" "success" "true"
          valid_json "$(api GET /api/system/stale-locks)" && ok "Stale locks → valid JSON"   || fail "Stale locks → invalid JSON"
          valid_json "$(api GET /api/monitoring/inotify)" && ok "Inotify stats → valid JSON" || fail "Inotify stats → invalid JSON"
          valid_json "$(api GET /api/system/disks)"        && ok "Disk discovery → valid JSON" || fail "Disk discovery → invalid JSON"
          valid_json "$(api GET /api/system/zfs-gate-status)" && ok "ZFS gate → valid JSON"  || fail "ZFS gate → invalid JSON"
          assert_json "System settings" "$(api GET /api/system/settings)" "success" "true"
          valid_json "$(api GET /api/system/ntp)" && ok "NTP status → valid JSON" || fail "NTP status → invalid JSON"
          valid_json "$(api GET /api/system/ups)" && ok "UPS status → valid JSON" || fail "UPS status → invalid JSON"

          # ── Phase 4: ZFS pools and datasets ───────────────────────────────────

          POOLS=$(api GET /api/zfs/pools)
          assert_json "ZFS list pools → success" "$POOLS" "success" "true"
          POOL_COUNT=$(echo "$POOLS" | python3 -c \
            "import sys,json; print(len(json.load(sys.stdin).get('data',[])))" 2>/dev/null || echo 0)
          [ "$POOL_COUNT" -ge 1 ] && ok "ZFS pools → $POOL_COUNT pool(s) returned" \
                                   || fail "ZFS pools → no pools returned"

          assert_json "ZFS list datasets" "$(api GET /api/zfs/datasets)" "success" "true"

          # Create a test dataset inside the CI loopback pool
          CREATE=$(api POST /api/zfs/datasets '{"name":"testpool/ci-test","compression":"lz4"}')
          assert_json "ZFS create dataset" "$CREATE" "success" "true"
          sudo zfs list testpool/ci-test &>/dev/null \
            && ok "ZFS dataset exists on system after create" \
            || fail "ZFS dataset not found on system after create"

          # Snapshot lifecycle
          SNAP=$(api POST /api/zfs/snapshots '{"dataset":"testpool/ci-test","name":"ci-snap-1"}')
          assert_json "ZFS create snapshot" "$SNAP" "success" "true"
          sudo zfs list -t snapshot testpool/ci-test@ci-snap-1 &>/dev/null \
            && ok "ZFS snapshot exists on system after create" \
            || fail "ZFS snapshot not found on system"

          LIST_SNAPS=$(api GET '/api/zfs/snapshots?dataset=testpool/ci-test')
          assert_json "ZFS list snapshots" "$LIST_SNAPS" "success" "true"
          SNAP_COUNT=$(echo "$LIST_SNAPS" | python3 -c \
            "import sys,json; print(json.load(sys.stdin).get('count',0))" 2>/dev/null || echo 0)
          [ "$SNAP_COUNT" -ge 1 ] && ok "ZFS list snapshots → $SNAP_COUNT returned" \
                                   || fail "ZFS list snapshots → expected ≥1, got $SNAP_COUNT"

          assert_json "ZFS rollback snapshot" \
            "$(api POST /api/zfs/snapshots/rollback '{"snapshot":"testpool/ci-test@ci-snap-1"}')" \
            "success" "true"

          DESTROY=$(api DELETE /api/zfs/snapshots '{"snapshot":"testpool/ci-test@ci-snap-1"}')
          assert_json "ZFS destroy snapshot" "$DESTROY" "success" "true"
          sudo zfs list -t snapshot testpool/ci-test@ci-snap-1 &>/dev/null \
            && fail "ZFS snapshot still exists after destroy" \
            || ok "ZFS snapshot gone from system after destroy"

          # Health, iostat, events, capacity, smart
          valid_json "$(api GET /api/zfs/health)"    && ok "ZFS health → valid JSON"    || fail "ZFS health → invalid JSON"
          valid_json "$(api GET /api/zfs/iostat)"    && ok "ZFS iostat → valid JSON"    || fail "ZFS iostat → invalid JSON"
          valid_json "$(api GET /api/zfs/events)"    && ok "ZFS events → valid JSON"    || fail "ZFS events → invalid JSON"
          valid_json "$(api GET /api/zfs/smart)"     && ok "ZFS SMART → valid JSON"     || fail "ZFS SMART → invalid JSON"
          valid_json "$(api GET /api/zfs/capacity)"  && ok "ZFS capacity → valid JSON"  || fail "ZFS capacity → invalid JSON"
          valid_json "$(api GET /api/zfs/disk-latency)" && ok "ZFS disk-latency → valid JSON" || fail "ZFS disk-latency → invalid JSON"
          valid_json "$(api GET '/api/zfs/scrub/status?pool=testpool')" && ok "ZFS scrub status → valid JSON" || fail "ZFS scrub status → invalid JSON"
          valid_json "$(api GET /api/zfs/scrub/schedule)" && ok "ZFS scrub schedule → valid JSON" || fail "ZFS scrub schedule → invalid JSON"
          valid_json "$(api GET /api/zfs/encryption/list)" && ok "ZFS encryption list → valid JSON" || fail "ZFS encryption list → invalid JSON"
          valid_json "$(api GET /api/snapshots/schedules)" && ok "Snapshot schedules → valid JSON" || fail "Snapshot schedules → invalid JSON"
          valid_json "$(api GET '/api/timemachine/versions?dataset=testpool/ci-test')" && ok "Time machine versions → valid JSON" || fail "Time machine versions → invalid JSON"

          # ── Phase 5: User management ──────────────────────────────────────────

          USERS=$(api GET /api/rbac/users)
          assert_json "List users → success" "$USERS" "success" "true"
          ADMIN_IN=$(echo "$USERS" | python3 -c \
            "import sys,json; print('yes' if any(u['username']=='admin' for u in json.load(sys.stdin).get('users',[])) else 'no')" 2>/dev/null || echo no)
          [ "$ADMIN_IN" = "yes" ] && ok "Admin visible in user list" || fail "Admin not in user list"

          CREATE_USER=$(api POST /api/users/create \
            '{"action":"create","username":"ci-testuser","password":"CiTest1!Pass","email":"ci@test.local","role":"user"}')
          assert_json "Create test user" "$CREATE_USER" "success" "true"

          USERS2=$(api GET /api/rbac/users)
          NEW_IN=$(echo "$USERS2" | python3 -c \
            "import sys,json; print('yes' if any(u['username']=='ci-testuser' for u in json.load(sys.stdin).get('users',[])) else 'no')" 2>/dev/null || echo no)
          [ "$NEW_IN" = "yes" ] && ok "Test user visible in list after create" || fail "Test user not in list after create"

          valid_json "$(api GET /api/rbac/groups)"          && ok "Groups list → valid JSON"     || fail "Groups list → invalid JSON"
          valid_json "$(api GET /api/rbac/me/permissions)"  && ok "My permissions → valid JSON"  || fail "My permissions → invalid JSON"
          valid_json "$(api GET /api/rbac/me/roles)"        && ok "My roles → valid JSON"        || fail "My roles → invalid JSON"
          valid_json "$(api GET /api/auth/tokens)"          && ok "API tokens → valid JSON"      || fail "API tokens → invalid JSON"

          # ── Phase 6: Shares, network, misc ───────────────────────────────────

          valid_json "$(api GET /api/shares)"              && ok "Shares list → valid JSON"       || fail "Shares list → invalid JSON"
          valid_json "$(api GET /api/shares/nfs/list)"     && ok "NFS exports → valid JSON"       || fail "NFS exports → invalid JSON"
          valid_json "$(api GET /api/network/vlan)"        && ok "VLANs → valid JSON"             || fail "VLANs → invalid JSON"
          valid_json "$(api GET /api/network/bond)"        && ok "Bonds → valid JSON"             || fail "Bonds → invalid JSON"
          valid_json "$(api GET /api/git-sync/config)"     && ok "Git sync config → valid JSON"   || fail "Git sync config → invalid JSON"
          valid_json "$(api GET /api/git-sync/status)"     && ok "Git sync status → valid JSON"   || fail "Git sync status → invalid JSON"
          valid_json "$(api GET /api/git-sync/stacks)"     && ok "Git sync stacks → valid JSON"   || fail "Git sync stacks → invalid JSON"
          valid_json "$(api GET /api/git-sync/repos)"      && ok "Git sync repos → valid JSON"    || fail "Git sync repos → invalid JSON"
          valid_json "$(api GET /api/git-sync/credentials)" && ok "Git sync creds → valid JSON"  || fail "Git sync creds → invalid JSON"
          valid_json "$(api GET /api/alerts/webhooks)"     && ok "Webhooks → valid JSON"          || fail "Webhooks → invalid JSON"
          valid_json "$(api GET /api/alerts/smtp)"         && ok "SMTP config → valid JSON"       || fail "SMTP config → invalid JSON"
          valid_json "$(api GET /api/alerts/telegram)"     && ok "Telegram config → valid JSON"   || fail "Telegram config → invalid JSON"
          valid_json "$(api GET /api/ldap/config)"         && ok "LDAP config → valid JSON"       || fail "LDAP config → invalid JSON"
          valid_json "$(api GET /api/ldap/status)"         && ok "LDAP status → valid JSON"       || fail "LDAP status → invalid JSON"
          valid_json "$(api GET /api/ldap/circuit-breaker)" && ok "LDAP CB → valid JSON"         || fail "LDAP CB → invalid JSON"
          valid_json "$(api GET /api/sandbox/list)"        && ok "Sandbox list → valid JSON"      || fail "Sandbox list → invalid JSON"
          valid_json "$(api GET /api/gitops/status)"       && ok "GitOps status → valid JSON"     || fail "GitOps status → invalid JSON"
          valid_json "$(api GET /api/firewall/status)"     && ok "Firewall status → valid JSON"   || fail "Firewall status → invalid JSON"
          valid_json "$(api GET /api/certs/list)"          && ok "Certs list → valid JSON"        || fail "Certs list → invalid JSON"
          valid_json "$(api GET /api/trash/list)"          && ok "Trash list → valid JSON"        || fail "Trash list → invalid JSON"
          valid_json "$(api GET /api/ha/status)"           && ok "HA status → valid JSON"         || fail "HA status → invalid JSON"
          valid_json "$(api GET /api/ha/local)"            && ok "HA local → valid JSON"          || fail "HA local → invalid JSON"
          valid_json "$(api GET /api/iscsi/status)"        && ok "iSCSI status → valid JSON"      || fail "iSCSI status → invalid JSON"
          valid_json "$(api GET /api/iscsi/targets)"       && ok "iSCSI targets → valid JSON"     || fail "iSCSI targets → invalid JSON"
          valid_json "$(api GET /api/nixos/detect)"        && ok "NixOS detect → valid JSON"      || fail "NixOS detect → invalid JSON"
          valid_json "$(api GET /api/removable/list)"      && ok "Removable media → valid JSON"   || fail "Removable media → invalid JSON"
          valid_json "$(api GET /api/power/disks)"         && ok "Power disks → valid JSON"       || fail "Power disks → invalid JSON"

          # Command injection blocked
          INJECT=$(api POST /api/zfs/command \
            "{\"command\":\"ls\",\"args\":[\"/etc/passwd\"],\"session_id\":\"$SESSION\",\"user\":\"admin\"}")
          if echo "$INJECT" | grep -q '"success":false\|Forbidden\|not allowed'; then
            ok "Command injection blocked"
          else
            fail "Command injection NOT blocked"
          fi

          # Prometheus metrics (plaintext)
          PROM=$(curl -sf --max-time 5 "$BASE/metrics" -H "X-Session-ID: $SESSION" -H "X-User: admin")
          [ -n "$PROM" ] && ok "Prometheus /metrics endpoint responds" || fail "Prometheus /metrics no response"

          # ── Phase 7: Logout ───────────────────────────────────────────────────

          LOGOUT=$(api POST /api/auth/logout)
          assert_json "Logout → success" "$LOGOUT" "success" "true"

          AUTHED=$(curl -sf --max-time 5 "$BASE/api/auth/check" \
            -H "X-Session-ID: $SESSION" | python3 -c \
            "import sys,json; print(json.load(sys.stdin).get('authenticated','false'))" 2>/dev/null || echo false)
          [ "$AUTHED" = "False" ] || [ "$AUTHED" = "false" ] \
            && ok "Session invalidated after logout" \
            || fail "Session still valid after logout"

          # ── Summary ───────────────────────────────────────────────────────────

          echo ""
          echo "══════════════════════════════════════════"
          echo "  Results: ✓ $PASS passed   ✗ $FAIL failed"
          echo "══════════════════════════════════════════"
          if [ "$FAIL" -gt 0 ]; then
            echo "Failures:"
            printf "$FAILURES\n"
            exit 1
          fi
          echo "All API integration tests passed"

      - name: Verify ZFS pool still intact
        run: |
          sudo zpool status testpool | grep -q "ONLINE"
          echo "✓ ZFS pool ONLINE"

      - name: Capture daemon log on failure
        if: failure()
        run: |
          echo "=== dplaned log ==="
          cat /tmp/dplaned.log || true

      - name: Cleanup
        if: always()
        run: |
          [ -f /tmp/dplaned.pid ] && sudo kill $(cat /tmp/dplaned.pid) 2>/dev/null || true
          sudo zpool destroy testpool 2>/dev/null || true
          sudo losetup -d "$LOOP0" "$LOOP1" "$LOOP2" 2>/dev/null || true

  # ── Job 3: Install script dry-run (no root side effects) ───────────────────
  installer:
    name: Installer syntax + pre-flight check
    runs-on: ubuntu-22.04

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check install.sh syntax
        run: bash -n install.sh && echo "✓ install.sh syntax valid"

      - name: Check get.sh syntax
        run: bash -n get.sh && echo "✓ get.sh syntax valid"

      - name: Check all scripts syntax
        run: |
          find scripts/ nixos/ -name "*.sh" | while read f; do
            bash -n "$f" && echo "✓ $f" || echo "✗ $f"
          done

      - name: Confirm VERSION file matches install.sh
        run: |
          FILE_VER="$(cat VERSION)"
          SCRIPT_VER="$(grep 'readonly VERSION=' install.sh | grep -oP '[0-9]+\.[0-9]+\.[0-9]+')"
          echo "VERSION file: $FILE_VER  install.sh: $SCRIPT_VER"
          [ "$FILE_VER" = "$SCRIPT_VER" ]
          echo "✓ Versions consistent"

      - name: Confirm no stale version references in functional files
        run: |
          PREV="3.2.0"
          CURR="$(cat VERSION)"
          # Exclude: changelog, release notes, historical install-guide refs,
          # feature-introduction comments in Go source, and the kernel fallback string
          BAD=$(grep -rl "$PREV" \
            --include="*.sh" --include="*.html" --include="*.js" \
            --include="*.json" --include="*.nix" --include="*.service" \
            --include="*.conf" \
            . \
            | grep -v "vendor\|\.git\|CHANGELOG\|RELEASE-NOTES\|INSTALLATION-GUIDE\|TROUBLESHOOTING\|README\|upgrade-with-rollback" \
            | xargs grep -l "$PREV" 2>/dev/null || true)
          if [ -n "$BAD" ]; then
            echo "✗ Stale version $PREV found in:"
            echo "$BAD"
            exit 1
          fi
          echo "✓ No stale $PREV references in functional files"
